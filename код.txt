#include "stdafx.h"
#include "ContentBrowser.h"
#include "../Editors/xrEProps/Tree/Choose/UIChooseForm.h"
#include "../Editors/xrECore/Editor/Library.h"
#include "../Editors/LevelEditor/UI/Tools/UIObjectTool.h"
#include "../xrCore/FS.h"
#include <algorithm>
#include <windows.h>
#include <commdlg.h>
#include <cctype>
#include <iterator>

xr_string UIContentBrowser::NormalizeName(xr_string s) {
    while (!s.empty() && (s[0] == '\\' || s[0] == '/')) s.erase(0, 1);
    std::replace(s.begin(), s.end(), '/', '\\');
    return s;
}

bool UIContentBrowser::IsValidName(const xr_string& name) {
    if (name.empty() || name.find_first_of("@#,`") != xr_string::npos)
        return false;
    for (char c : name)
        if (!std::isalnum(c) && c != '_' && c != '\\' && c != '.')
            return false;
    return true;
}

bool UIContentBrowser::ResolveObjectFile(const xr_string& candidate, xr_string& outFullPath) {
    xr_string name = NormalizeName(candidate);
    if (!IsValidName(name)) {
        ELog.Msg(mtError, "ResolveObjectFile: Invalid name: %s", name.c_str());
        return false;
    }
    string_path tmp;
    if (FS.exist(tmp, "$objects$", name.c_str())) {
        outFullPath = name;
        ELog.Msg(mtInformation, "ResolveObjectFile: Found file: %s in $objects$", name.c_str());
        return true;
    }
    auto has_dot = name.find_last_of('.');
    xr_string base = (has_dot == xr_string::npos) ? name : name.substr(0, has_dot);
    xr_string rel = base + ".object";
    if (FS.exist(tmp, "$objects$", rel.c_str())) {
        outFullPath = rel;
        ELog.Msg(mtInformation, "ResolveObjectFile: Found file: %s in $objects$", rel.c_str());
        return true;
    }
    rel = base + ".lwo";
    if (FS.exist(tmp, "$objects$", rel.c_str())) {
        outFullPath = rel;
        ELog.Msg(mtInformation, "ResolveObjectFile: Found file: %s in $objects$", rel.c_str());
        return true;
    }
    ELog.Msg(mtError, "ResolveObjectFile: File not found: %s in $objects$", name.c_str());
    return false;
}

UIContentBrowser* UIContentBrowser::Instance() {
    static UIContentBrowser instance;
    return &instance;
}
//
UIContentBrowser::UIContentBrowser()
{
    m_CurrentPath.clear();
    m_RefreshInProgress = false;
    m_Selection = false;
    m_SelectedItem.clear();
    m_SearchQuery.clear();
    m_PendingObject.clear();
    m_AddButtonClicked = false;
    m_RenameDialogOpen = false;
    m_DeleteDialogOpen = false;
    m_NewNameBuffer[0] = '\0';
    m_ObjectList = xr_new<UIItemListForm>();
    m_TextureNull.create("\\ed\\bar\\rollic\\contentbrowser\\StaticMeshActor_64");
    m_TextureNull->Load();
    if (FS.exist("$game_textures$", "ed\\bar\\rollic\\contentbrowser\\folder.dds"))
        m_tFolder.create("ed\\bar\\rollic\\contentbrowser\\folder");
    else
        m_tFolder.create("$game_textures$\\ed\\folder");
    m_tFolder->Load();

    if (FS.exist("$game_textures$", "ed\\bar\\rollic\\contentbrowser\\folder-closed.dds"))
        m_tFolderClosed.create("ed\\bar\\rollic\\contentbrowser\\folder-closed");
    else
        m_tFolderClosed.create("$game_textures$\\ed\\folder");
    m_tFolderClosed->Load();

    if (FS.exist("$game_textures$", "ed\\bar\\rollic\\contentbrowser\\folder-open.dds"))
        m_tFolderOpen.create("ed\\bar\\rollic\\contentbrowser\\folder-open");
    else
        m_tFolderOpen.create("$game_textures$\\ed\\folder");
    m_tFolderOpen->Load();

    if (FS.exist("$game_textures$", "ed\\bar\\rollic\\contentbrowser\\up.dds"))
        m_tUp.create("ed\\bar\\rollic\\contentbrowser\\up");
    else
        m_tUp.create("$game_textures$\\ed\\ed_nodata");
    m_tUp->Load();
    if (FS.exist("$game_textures$", "ed\\bar\\rollic\\contentbrowser\\down.dds"))
        m_tDown.create("ed\\bar\\rollic\\contentbrowser\\down");
    else
        m_tDown.create("$game_textures$\\ed\\ed_nodata");
    m_tDown->Load();
    m_tAdd.create("ed\\bar\\rollic\\contentbrowser\\add");
    m_tAdd->Load();
    m_tRefresh.create("ed\\bar\\rollic\\contentbrowser\\refresh");
    m_tRefresh->Load();
    m_tRename.create("ed\\bar\\rollic\\contentbrowser\\rename");
    m_tRename->Load();
    if (FS.exist("$game_textures$", "ed\\bar\\rollic\\contentbrowser\\delete.dds"))
        m_tDelete.create("ed\\bar\\rollic\\contentbrowser\\delete");
    else
        m_tDelete.create("$game_textures$\\ed\\ed_nodata");
    m_tDelete->Load();
    m_tTrashFolder.create("ed\\bar\\rollic\\contentbrowser\\trash_folder");
    m_tTrashFolder->Load();
    RefreshList();
}

UIContentBrowser::~UIContentBrowser()
{
    for (auto& pair : m_PreviewCache)
        if (pair.second && pair.second != m_TextureNull->surface_get()) {}
    m_PreviewCache.clear();
    m_TextureNull.destroy();
    m_tFolder.destroy();
    m_tFolderClosed.destroy();
    m_tFolderOpen.destroy();
    m_tUp.destroy();
    m_tDown.destroy();
    m_tAdd.destroy();
    m_tRefresh.destroy();
    m_tRename.destroy();
    m_tDelete.destroy();
    m_tTrashFolder.destroy();
    xr_delete(m_ObjectList);
}

void UIContentBrowser::BuildDirectoryTree() {
    m_DirectoryTree.children.clear();
    m_DirectoryTree.name.clear();
    m_DirectoryTree.isFolder = true;
    m_DirectoryTree.fullPath.clear();
    m_DirectoryTree.texture = m_tFolder->surface_get();

    FS_FileSet lst;
    if (Lib.GetObjects(lst)) {
        xr_string searchLower = m_SearchQuery;
        std::transform(searchLower.begin(), searchLower.end(), searchLower.begin(), [](char c) { return std::tolower(c); });

        for (const auto& file : lst) {
            xr_string relativeName = file.name;
            if (!IsValidName(relativeName))
                continue;

            xr_string relativeLower = relativeName;
            std::transform(relativeLower.begin(), relativeLower.end(), relativeLower.begin(), [](char c) { return std::tolower(c); });
            if (!m_SearchQuery.empty() && relativeLower.find(searchLower) == xr_string::npos)
                continue;

            std::vector<xr_string> parts;
            size_t pos = 0;
            while ((pos = relativeName.find('\\')) != xr_string::npos) {
                parts.push_back(relativeName.substr(0, pos));
                relativeName.erase(0, pos + 1);
            }
            parts.push_back(relativeName);

            DirectoryNode* current = &m_DirectoryTree;
            xr_string currentPath;
            for (size_t i = 0; i < parts.size(); ++i) {
                const auto& part = parts[i];
                if (!currentPath.empty()) currentPath += "\\";
                currentPath += part;

                if (i < parts.size() - 1) {
                    auto it = std::find_if(current->children.begin(), current->children.end(),
                        [&part](const DirectoryNode& node) { return node.name == part && node.isFolder; });
                    if (it == current->children.end()) {
                        DirectoryNode folder;
                        folder.name = part;
                        folder.isFolder = true;
                        folder.fullPath = currentPath;
                        folder.texture = (currentPath == "_trash") ? m_tTrashFolder->surface_get() : m_tFolder->surface_get();
                        current->children.push_back(folder);
                        current = &current->children.back();
                    }
                    else {
                        current = &*it;
                    }
                }
                else {
                    bool isFolder = relativeName.find('\\') != xr_string::npos;
                    auto it = std::find_if(current->children.begin(), current->children.end(),
                        [&part, isFolder](const DirectoryNode& node) { return node.name == part && node.isFolder == isFolder; });
                    if (it == current->children.end()) {
                        DirectoryNode node;
                        node.name = part;
                        node.isFolder = isFolder;
                        node.fullPath = currentPath;
                        node.texture = isFolder ? ((currentPath == "_trash") ? m_tTrashFolder->surface_get() : m_tFolder->surface_get()) : m_TextureNull->surface_get();
                        current->children.push_back(node);
                    }
                }
            }
        }
    }

    auto sortChildren = [](xr_vector<DirectoryNode, xalloc<DirectoryNode>>& children) {
        std::sort(children.begin(), children.end(),
            [](const DirectoryNode& a, const DirectoryNode& b) {
                return a.isFolder == b.isFolder ? a.name < b.name : a.isFolder > b.isFolder;
            });
    };
    std::function<void(DirectoryNode&)> sortRecursive = [&](DirectoryNode& node) {
        sortChildren(node.children);
        for (auto& child : node.children) {
            if (child.isFolder) sortRecursive(child);
        }
    };
    sortChildren(m_DirectoryTree.children);
    for (auto& child : m_DirectoryTree.children) {
        if (child.isFolder) sortRecursive(child);
    }
}

void UIContentBrowser::DrawItem(const DirectoryNode& node, const xr_string& parentPath, float indentLevel) {
    ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_OpenOnArrow;
    if (!node.isFolder) {
        flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen;
    }
    if (m_SelectedItem == node.name) {
        flags |= ImGuiTreeNodeFlags_Selected;
    }
    if (node.isFolder && !m_SearchQuery.empty()) {
        flags |= ImGuiTreeNodeFlags_DefaultOpen;
    }

    xr_string itemPath = parentPath.empty() ? node.name : parentPath + "\\" + node.name;
    bool isOpen = false;

    if (node.isFolder) {
        ImGui::Image(node.fullPath == m_CurrentPath ? m_tFolderOpen->surface_get() : node.texture, ImVec2(16, 16));
        ImGui::SameLine();
        isOpen = ImGui::TreeNodeEx(node.name.c_str(), flags);
    }
    else {
        ImTextureID imgID = m_PreviewCache.find(node.name) != m_PreviewCache.end() ? m_PreviewCache[node.name] : m_TextureNull->surface_get();
        ImGui::Image(imgID, ImVec2(16, 16));
        ImGui::SameLine();
        ImGui::TreeNodeEx(node.name.c_str(), flags);
    }

    if (ImGui::IsItemClicked()) {
        OnItemClicked(node.name, node.isFolder, itemPath);
    }

    if (isOpen) {
        for (const auto& child : node.children) {
            DrawItem(child, itemPath, indentLevel + ImGui::GetTreeNodeToLabelSpacing());
        }
        ImGui::TreePop();
    }
}

void UIContentBrowser::Draw()
{
    static bool showWindow = true;

    if (ImGui::IsKeyDown(ImGuiKey_LeftCtrl) && ImGui::IsKeyPressed(ImGuiKey_Space, false)) {
        showWindow = !showWindow;
    }

    if (!showWindow) {
        return;
    }

    ImGui::Begin("Content Browser", &showWindow, ImGuiWindowFlags_None);
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 10.0f);
    ImGui::Columns(2, nullptr, true);
    ImGui::SetColumnWidth(0, 230.0f);

    {
        ImGui::BeginChild("Object List", ImVec2(0, 0), true, ImGuiWindowFlags_NoScrollbar);
        ImGui::BeginGroup();
        float search_width = 208.0f;
        ImGui::SetNextItemWidth(search_width);
        char buffer[256];
        xr_strcpy(buffer, m_SearchQuery.c_str());
        if (ImGui::InputTextWithHint("##Search", "Search", buffer, sizeof(buffer))) {
            m_SearchQuery = buffer;
            RefreshList();
        }
        ImGui::EndGroup();
        ImGui::Separator();
        ImGui::BeginChild("ScrollableList", ImVec2(0, 0), false);
        for (const auto& node : m_DirectoryTree.children) {
            if (node.isFolder) {
                DrawItem(node, "", 0.0f);
            }
            else {
                ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen;
                if (m_SelectedItem == node.name) {
                    flags |= ImGuiTreeNodeFlags_Selected;
                }
                ImGui::PushID(node.name.c_str());
                ImGui::Indent(0.0f);
                ImGui::BeginGroup();
                ImGui::Image(node.texture, ImVec2(20, 20));
                ImGui::SameLine(0.0f, 4.0f);
                bool isOpen = ImGui::TreeNodeEx(node.name.c_str(), flags);
                if (ImGui::IsItemClicked()) {
                    OnItemClicked(node.name, false, "");
                }
                ImGui::EndGroup();
                ImGui::Unindent(0.0f);
                ImGui::PopID();
            }
        }
        ImGui::EndChild();
        ImGui::Separator();
        ImGui::EndGroup();
        ImGui::EndChild();

        RStringVec selectedItems;
        if (m_ObjectList->GetSelected(selectedItems) && !selectedItems.empty()) {
            xr_string sel = selectedItems[0].c_str();
            if (m_SelectedItem != sel && IsValidName(sel)) {
                m_SelectedItem = sel;
                ESceneObjectTool* objTool = dynamic_cast<ESceneObjectTool*>(Scene->GetTool(OBJCLASS_SCENEOBJECT));
                if (objTool && objTool->pForm) {
                    UIObjectTool* uiObjTool = dynamic_cast<UIObjectTool*>(objTool->pForm);
                    if (uiObjTool) {
                        xr_string fullPath = m_CurrentPath;
                        if (!fullPath.empty()) fullPath += "\\";
                        fullPath += m_SelectedItem;
                        uiObjTool->SetCurrent(fullPath.c_str());
                        m_PendingObject = fullPath;
                    }
                }
            }
            else if (!IsValidName(sel)) {
                m_SelectedItem.clear();
                m_PendingObject.clear();
            }
        }
    }

    ImGui::NextColumn();
    ImGui::BeginGroup();
    if (ImGui::ImageButton(m_tUp->surface_get(), ImVec2(20, 20)) && !m_CurrentPath.empty())
    {
        size_t pos = m_CurrentPath.find_last_of('\\', m_CurrentPath.length() - 2);
        m_PathHistory.push_back(m_CurrentPath);
        m_CurrentPath = pos != xr_string::npos ? m_CurrentPath.substr(0, pos) : "";
        m_PreviewCache.clear();
        m_CacheOrder.clear();
        m_SelectedItem.clear();
        m_PendingObject.clear();
        RefreshList();
    }
    ImGui::SameLine(0.0f, 4.0f);
    if (ImGui::ImageButton(m_tDown->surface_get(), ImVec2(20, 20)) && !m_PathHistory.empty())
    {
        m_CurrentPath = m_PathHistory.back();
        m_PathHistory.pop_back();
        m_PreviewCache.clear();
        m_CacheOrder.clear();
        m_SelectedItem.clear();
        m_PendingObject.clear();
        RefreshList();
    }
    ImGui::SameLine(0.0f, 4.0f);
    ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.059f, 0.059f, 0.059f, 1.0f)); // #0f0f0f
    ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.208f, 0.208f, 0.208f, 1.0f)); // #353535
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.753f, 0.753f, 0.753f, 1.0f)); // #c0c0c0
    ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1.0f);
    ImGui::BeginChild("PathDisplay", ImVec2(0, ImGui::GetTextLineHeightWithSpacing() + 2.0f), true);
    ImGui::Text("Path: %s", m_CurrentPath.c_str());
    ImGui::EndChild();
    ImGui::PopStyleVar();
    ImGui::PopStyleColor(3);
    ImGui::EndGroup();

    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.22f, 0.22f, 0.22f, 1.0f)); // #383838
    ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.22f, 0.22f, 0.22f, 1.0f)); // #383838
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.22f, 0.22f, 0.22f, 1.0f)); // #383838
    ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1.0f);
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 5.0f);
    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(4, 2));
    if (ImGui::Button("##RefreshButton", ImVec2(80, 20)))
    {
        m_PreviewCache.clear();
        m_CacheOrder.clear();
        m_SelectedItem.clear();
        m_PendingObject.clear();
        RefreshList();
    }
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
    ImVec2 refresh_pos = ImGui::GetItemRectMin();
    ImGui::GetWindowDrawList()->AddImage(m_tRefresh->surface_get(),
        ImVec2(refresh_pos.x + 4, refresh_pos.y + 2),
        ImVec2(refresh_pos.x + 20, refresh_pos.y + 18));
    ImGui::GetWindowDrawList()->AddText(
        ImVec2(refresh_pos.x + 24, refresh_pos.y + 2),
        ImGui::GetColorU32(ImGuiCol_Text), "Refresh");
    ImGui::SameLine();

    if (ImGui::Button("##ImportButton", ImVec2(80, 20)))
    {

        OPENFILENAME ofn;
        char szFile[260 * 16] = { 0 };
        ZeroMemory(&ofn, sizeof(OPENFILENAME));
        ofn.lStructSize = sizeof(OPENFILENAME);
        ofn.hwndOwner = NULL;
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = sizeof(szFile);
        ofn.lpstrFilter = "All Files\0*.*\0Object Files\0*.ogf;*.object\0";
        ofn.nFilterIndex = 1;
        ofn.lpstrFileTitle = NULL;
        ofn.nMaxFileTitle = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT | OFN_EXPLORER;
        if (GetOpenFileName(&ofn))
        {
            xr_string destDir = NormalizeName(m_CurrentPath);
            if (!destDir.empty()) destDir += "\\";
            xr_string baseDestPath = FS.get_path("$objects$")->m_Path + destDir;
            CreateDirectoryA(baseDestPath.c_str(), NULL);
            ELog.Msg(mtInformation, "Import: Creating directory %s", baseDestPath.c_str());

            char* fileName = szFile;
            xr_string sourcePath = fileName;
            fileName += sourcePath.length() + 1;
            if (*fileName == '\0')
            {
                size_t lastSlash = sourcePath.find_last_of('\\');
                xr_string fileOnly = (lastSlash != xr_string::npos) ? sourcePath.substr(lastSlash + 1) : sourcePath;
                xr_string destPath = destDir + fileOnly;
                xr_string fullDestPath = FS.get_path("$objects$")->m_Path + destPath;
                ELog.Msg(mtInformation, "Import: Copying single file %s to %s", sourcePath.c_str(), fullDestPath.c_str());
                if (CopyFileA(sourcePath.c_str(), fullDestPath.c_str(), FALSE)) {
                    ELog.Msg(mtInformation, "Import: Successfully copied %s", fullDestPath.c_str());
                    RefreshList();
                }
                else {
                    DWORD error = GetLastError();
                    ELog.DlgMsg(mtError, "Import: Failed to copy %s to %s (Error code: %lu)", sourcePath.c_str(), fullDestPath.c_str(), error);
                }
            }
            else
            {
                while (*fileName != '\0')
                {
                    xr_string fileOnly = fileName;
                    xr_string fullSourcePath = sourcePath + "\\" + fileOnly;
                    xr_string destPath = destDir + fileOnly;
                    xr_string fullDestPath = FS.get_path("$objects$")->m_Path + destPath;
                    ELog.Msg(mtInformation, "Import: Copying multiple file %s to %s", fullSourcePath.c_str(), fullDestPath.c_str());
                    if (CopyFileA(fullSourcePath.c_str(), fullDestPath.c_str(), FALSE)) {
                        ELog.Msg(mtInformation, "Import: Successfully copied %s", fullDestPath.c_str());
                        RefreshList();
                    }
                    else {
                        DWORD error = GetLastError();
                        ELog.DlgMsg(mtError, "Import: Failed to copy %s to %s (Error code: %lu)", fullSourcePath.c_str(), fullDestPath.c_str(), error);
                    }
                    fileName += fileOnly.length() + 1;
                }
            }
        }
    }
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);

    ImVec2 import_pos = ImGui::GetItemRectMin();
    ImGui::GetWindowDrawList()->AddImage(m_tAdd->surface_get(),
        ImVec2(import_pos.x + 4, import_pos.y + 2),
        ImVec2(import_pos.x + 20, import_pos.y + 18));
    ImGui::GetWindowDrawList()->AddText(
        ImVec2(import_pos.x + 24, import_pos.y + 2),

        ImGui::GetColorU32(ImGuiCol_Text), "Import");
    ImGui::SameLine();

    if (ImGui::Button("##RenameButton", ImVec2(80, 20)) && !m_SelectedItem.empty())
    {
        m_RenameDialogOpen = true;
        xr_strcpy(m_NewNameBuffer, m_SelectedItem.c_str());
    }
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
    ImVec2 rename_pos = ImGui::GetItemRectMin();
    ImGui::GetWindowDrawList()->AddImage(m_tRename->surface_get(),
        ImVec2(rename_pos.x + 4, rename_pos.y + 2),
        ImVec2(rename_pos.x + 20, rename_pos.y + 18));
    ImGui::GetWindowDrawList()->AddText(
        ImVec2(rename_pos.x + 24, rename_pos.y + 2),
        ImGui::GetColorU32(ImGuiCol_Text), "Rename");
    ImGui::SameLine();

    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.624f, 0.216f, 0.216f, 1.0f)); // #9f3737
    if (ImGui::Button("##DeleteButton", ImVec2(80, 20)) && !m_SelectedItem.empty())
    {
        m_DeleteDialogOpen = true;
    }
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
    ImGui::PopStyleColor();
    ImVec2 delete_pos = ImGui::GetItemRectMin();
    ImGui::GetWindowDrawList()->AddImage(m_tDelete->surface_get(),
        ImVec2(delete_pos.x + 4, delete_pos.y + 2),
        ImVec2(delete_pos.x + 20, delete_pos.y + 18));
    ImGui::GetWindowDrawList()->AddText(
        ImVec2(delete_pos.x + 24, delete_pos.y + 2),
        ImGui::GetColorU32(ImGuiCol_Text), "Delete");
    ImGui::PopStyleVar(2);
    ImGui::PopStyleColor(3);

    ImGui::SameLine();
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.0f, 0.7f, 0.0f, 1.0f));
    if (ImGui::Button("Test Spawn", ImVec2(80, 20)) && !m_SelectedItem.empty())
    {
        xr_string fullPath = m_CurrentPath;
        if (!fullPath.empty()) fullPath += "\\";
        fullPath += m_SelectedItem;
        Fvector pos = { 0.f, 0.f, 0.f };
        if (GetMouseScenePosition(pos))
            AddObjectToScene(fullPath, pos);
    }
    ImGui::PopStyleColor();

    if (m_RenameDialogOpen)
    {
        ImGui::OpenPopup("Rename Item");
        ImGui::SetNextWindowSize(ImVec2(300, 120));
        if (ImGui::BeginPopupModal("Rename Item", NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::Text("Enter new name for '%s':", m_SelectedItem.c_str());
            ImGui::Separator();
            ImGui::InputText("##NewName", m_NewNameBuffer, sizeof(m_NewNameBuffer));
            ImGui::Separator();
            if (ImGui::Button("OK", ImVec2(120, 0)))
            {
                xr_string newName = m_NewNameBuffer;
                if (IsValidName(newName) && !newName.empty() && newName != m_SelectedItem)
                {
                    RenameItem(newName);
                }
                m_RenameDialogOpen = false;
            }
            ImGui::SameLine();
            if (ImGui::Button("Cancel", ImVec2(120, 0)))
            {
                m_RenameDialogOpen = false;
            }
            ImGui::EndPopup();
        }
    }

    if (m_DeleteDialogOpen)
    {
        ImGui::OpenPopup("Delete Item");
        ImGui::SetNextWindowSize(ImVec2(300, 120));
        if (ImGui::BeginPopupModal("Delete Item", NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::Text("Are you sure you want to delete '%s'?", m_SelectedItem.c_str());
            ImGui::Separator();
            if (ImGui::Button("OK", ImVec2(120, 0)))
            {
                DeleteItem();
                m_DeleteDialogOpen = false;
            }
            ImGui::SameLine();
            if (ImGui::Button("Cancel", ImVec2(120, 0)))
            {
                m_DeleteDialogOpen = false;
            }
            ImGui::EndPopup();
        }
    }

    ImGui::BeginChild("Content", ImVec2(0, 0), true, ImGuiWindowFlags_AlwaysVerticalScrollbar);
    const float tileSize = 100.0f;
    const float spacing = 10.0f;
    float availableWidth = ImGui::GetContentRegionAvail().x;
    int columns = std::max(1, (int)(availableWidth / (tileSize + spacing)));
    if (availableWidth < (columns * (tileSize + spacing) + spacing)) {
        columns = std::max(1, columns - 1);
    }
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));
    if (ImGui::BeginTable("ContentTable", columns, ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_NoPadOuterX))
    {
        for (auto& item : m_Items)
        {
            ImGui::TableNextColumn();
            ImGui::BeginGroup();
            ImGui::PushID(item.name.c_str());
            bool isSelected = (m_SelectedItem == item.name);
            ImVec2 selectableSize(tileSize + spacing, tileSize + ImGui::GetTextLineHeightWithSpacing() + spacing);
            if (ImGui::Selectable("##selectable", isSelected, ImGuiSelectableFlags_AllowDoubleClick, selectableSize))
            {
                if (IsValidName(item.name)) {
                    m_SelectedItem = item.name;
                    m_ObjectList->SelectItem(item.name.c_str());
                    if (ESceneObjectTool* objTool = dynamic_cast<ESceneObjectTool*>(Scene->GetTool(OBJCLASS_SCENEOBJECT)))
                        if (objTool->pForm)
                            if (UIObjectTool* uiObjTool = dynamic_cast<UIObjectTool*>(objTool->pForm)) {
                                xr_string fullPath = m_CurrentPath;
                                if (!fullPath.empty()) fullPath += "\\";
                                fullPath += m_SelectedItem;
                                uiObjTool->SetCurrent(fullPath.c_str());
                                m_PendingObject = fullPath;
                            }
                    if (ImGui::IsMouseDoubleClicked(0) && item.isFolder) {
                        m_PathHistory.push_back(m_CurrentPath);
                        xr_string fullPath = m_CurrentPath;
                        if (!fullPath.empty()) fullPath += "\\";
                        fullPath += item.name;
                        OnItemClicked(item.name, item.isFolder, fullPath);
                    }
                }
            }
            // Если элемент выделен или на него наведён курсор, рисуем фон
            if (isSelected || ImGui::IsItemHovered()) {
                ImGui::GetWindowDrawList()->AddRectFilled(
                    ImGui::GetItemRectMin(),
                    ImGui::GetItemRectMax(),
                    ImGui::GetColorU32(ImGuiCol_FrameBgHovered) // Цвет фона при наведении
                );
            }
            ImVec2 rectMin = ImGui::GetItemRectMin();
            ImVec2 cur = rectMin;
            cur.x += 5.0f;
            cur.y += 5.0f;
            ImGui::SetCursorScreenPos(cur);
            ImTextureID iconID = item.isFolder ? (item.name == "_trash" ? m_tTrashFolder->surface_get() : m_tFolder->surface_get()) : m_TextureNull->surface_get();
            if (!item.isFolder) {
                iconID = LoadThumbnail(item.name); // а внутри LoadThumbnail используется m_CurrentPath

            }
            ImGui::Image(iconID, ImVec2(tileSize, tileSize)); // Заменяем ImageButton на Image
            ImGui::SetCursorScreenPos(ImVec2(cur.x, cur.y + tileSize + 2.0f));
            ImGui::TextWrapped("%s", item.name.c_str());
            ImGui::PopID();
            ImGui::EndGroup();
        }
        ImGui::EndTable();
    }
    ImGui::PopStyleVar();
    ImGui::EndChild();
    ImGui::Columns(1);
    if (m_Selection)
    {
        bool change = false;
        xr_string result;
        if (UIChooseForm::GetResult(change, result))
        {
            if (change)
            {
                xr_string candidate = NormalizeName(result);
                if (IsValidName(candidate)) {
                    xr_string fullCandidate = candidate;
                    if (!m_CurrentPath.empty() && fullCandidate.find(m_CurrentPath + "\\") != 0)
                        fullCandidate = m_CurrentPath + "\\" + fullCandidate;
                    m_PendingObject = fullCandidate;
                    ESceneObjectTool* objTool = dynamic_cast<ESceneObjectTool*>(Scene->GetTool(OBJCLASS_SCENEOBJECT));
                    if (objTool && objTool->pForm)
                        if (UIObjectTool* uiObjTool = dynamic_cast<UIObjectTool*>(objTool->pForm))
                            uiObjTool->SetCurrent(fullCandidate.c_str());
                }
            }
            m_Selection = false;
        }
        UIChooseForm::Update();
    }
    ImGui::PopStyleVar();

    if (!m_PendingObject.empty() && Tools->GetAction() == etaAdd && ImGui::IsMouseClicked(0))
    {
        xr_string fullCandidate;
        if (ResolveObjectFile(m_PendingObject, fullCandidate))
        {
            Fvector pos = { 0.f, 0.f, 0.f };
            if (GetMouseScenePosition(pos))
            {
                AddObjectToScene(fullCandidate, pos);
                ESceneObjectTool* objTool = dynamic_cast<ESceneObjectTool*>(Scene->GetTool(OBJCLASS_SCENEOBJECT));
                if (objTool && objTool->pForm)
                {
                    UIObjectTool* uiObjTool = dynamic_cast<UIObjectTool*>(objTool->pForm);
                    if (uiObjTool)
                        uiObjTool->SetCurrent(fullCandidate.c_str());
                }
            }
            else
            {
                ELog.DlgMsg(mtError, "Cannot get mouse position for scene placement.");
            }
        }
        else
        {
            ELog.DlgMsg(mtError, "Cannot place object, file does not exist or invalid: %s", m_PendingObject.c_str());
            m_PendingObject.clear();
        }
    }
    ImGui::PopStyleVar();

    m_AddButtonClicked = false;
    ImGui::End();
}

void UIContentBrowser::RenameItem(const xr_string& newName)
{
    if (m_SelectedItem.empty()) {
        ELog.DlgMsg(mtError, "No item selected for renaming.");
        return;
    }

    xr_string oldPath = m_CurrentPath;
    if (!oldPath.empty()) oldPath += "\\";
    oldPath += m_SelectedItem;
    xr_string newPath = m_CurrentPath;
    if (!newPath.empty()) newPath += "\\";
    newPath += newName;

    string_path oldPhysicalPath, newPhysicalPath;
    bool isFolder = false;

    xr_string normalizedOldPath = NormalizeName(oldPath);
    xr_string normalizedNewPath = NormalizeName(newPath);

    ELog.Msg(mtInformation, "RenameItem: Attempting to rename %s to %s", normalizedOldPath.c_str(), normalizedNewPath.c_str());

    if (FS.exist(oldPhysicalPath, "$fs_root$", (normalizedOldPath + "\\").c_str())) {
        isFolder = true;
        ELog.Msg(mtInformation, "RenameItem: Item %s is a folder in $fs_root$", normalizedOldPath.c_str());
    }
    else {
        xr_string resolvedOldPath;
        if (ResolveObjectFile(normalizedOldPath, resolvedOldPath)) {
            isFolder = false;
            normalizedOldPath = resolvedOldPath;
            ELog.Msg(mtInformation, "RenameItem: Resolved file path %s in $objects$", normalizedOldPath.c_str());
        }
        else {
            ELog.DlgMsg(mtError, "Item does not exist: %s (checked in $fs_root$ and $objects$)", normalizedOldPath.c_str());
            return;
        }
    }

    if (isFolder) {
        xr_string oldFullPath = FS.get_path("$fs_root$")->m_Path + normalizedOldPath;
        xr_string newFullPath = FS.get_path("$fs_root$")->m_Path + normalizedNewPath;
        if (FS.exist(newPhysicalPath, "$fs_root$", (normalizedNewPath + "\\").c_str())) {
            ELog.DlgMsg(mtError, "Folder already exists: %s", normalizedNewPath.c_str());
            return;
        }
        ELog.Msg(mtInformation, "RenameItem: Folder old path: %s, new path: %s", oldFullPath.c_str(), newFullPath.c_str());
        if (MoveFileA(oldFullPath.c_str(), newFullPath.c_str())) {
            m_SelectedItem = newName;
            RefreshList();
            ELog.Msg(mtInformation, "Folder renamed successfully: %s to %s", normalizedOldPath.c_str(), normalizedNewPath.c_str());
        }
        else {
            DWORD error = GetLastError();
            ELog.DlgMsg(mtError, "Failed to rename folder: %s to %s (Error code: %lu)", normalizedOldPath.c_str(), normalizedNewPath.c_str(), error);
        }
    }
    else {
        xr_string resolvedOldPath = normalizedOldPath;
        size_t dotPos = resolvedOldPath.find_last_of('.');
        xr_string extension = (dotPos != xr_string::npos) ? resolvedOldPath.substr(dotPos) : "";
        xr_string resolvedNewPath = newName;
        size_t newDotPos = newName.find_last_of('.');
        if (newDotPos == xr_string::npos || (newName.substr(newDotPos) != ".object" && newName.substr(newDotPos) != ".lwo")) {
            resolvedNewPath += extension;
            ELog.Msg(mtInformation, "RenameItem: Appended extension %s to new path: %s", extension.c_str(), resolvedNewPath.c_str());
        }
        newPath = m_CurrentPath;
        if (!newPath.empty()) newPath += "\\";
        newPath += resolvedNewPath;
        normalizedNewPath = NormalizeName(newPath);

        xr_string oldFullPath = FS.get_path("$objects$")->m_Path + normalizedOldPath;
        xr_string newFullPath = FS.get_path("$objects$")->m_Path + normalizedNewPath;
        if (FS.exist(newPhysicalPath, "$objects$", normalizedNewPath.c_str())) {
            ELog.DlgMsg(mtError, "File already exists: %s", normalizedNewPath.c_str());
            return;
        }

        xr_string oldFileName = normalizedOldPath;
        if (!m_CurrentPath.empty()) {
            size_t pos = normalizedOldPath.find(m_CurrentPath + "\\");
            if (pos == 0) {
                oldFileName = normalizedOldPath.substr(m_CurrentPath.length() + 1);
            }
        }
        xr_string newFileName = resolvedNewPath;
        if (!m_CurrentPath.empty()) {
            size_t pos = resolvedNewPath.find(m_CurrentPath + "\\");
            if (pos == 0) {
                newFileName = resolvedNewPath.substr(m_CurrentPath.length() + 1);
            }
        }
        xr_string oldBaseName = m_CurrentPath;
        if (!oldBaseName.empty()) oldBaseName += "\\";
        oldBaseName += oldFileName.substr(0, oldFileName.find_last_of('.'));
        xr_string newBaseName = m_CurrentPath;
        if (!newBaseName.empty()) newBaseName += "\\";
        newBaseName += newFileName.substr(0, newFileName.find_last_of('.'));
        xr_string oldThmPath = oldBaseName + ".thm";
        xr_string newThmPath = newBaseName + ".thm";
        xr_string oldThmFullPath = FS.get_path("$objects$")->m_Path + NormalizeName(oldThmPath);
        xr_string newThmFullPath = FS.get_path("$objects$")->m_Path + NormalizeName(newThmPath);
        bool thmRenamed = false;

        ELog.Msg(mtInformation, "RenameItem: Checking for thumbnail %s in $objects$", oldThmPath.c_str());
        if (FS.exist(oldPhysicalPath, "$objects$", oldThmPath.c_str())) {
            ELog.Msg(mtInformation, "RenameItem: Found thumbnail %s in $objects$", oldThmPath.c_str());
            if (FS.exist(newPhysicalPath, "$objects$", newThmPath.c_str())) {
                ELog.DlgMsg(mtError, "Thumbnail file already exists: %s", newThmPath.c_str());
                return;
            }
            ELog.Msg(mtInformation, "RenameItem: Attempting to rename thumbnail %s to %s", oldThmFullPath.c_str(), newThmFullPath.c_str());
            if (MoveFileA(oldThmFullPath.c_str(), newThmFullPath.c_str())) {
                thmRenamed = true;
                ELog.Msg(mtInformation, "Thumbnail renamed successfully: %s to %s", oldThmPath.c_str(), newThmPath.c_str());
            }
            else {
                DWORD error = GetLastError();
                ELog.DlgMsg(mtError, "Failed to rename thumbnail: %s to %s (Error code: %lu)", oldThmFullPath.c_str(), newThmFullPath.c_str(), error);
            }
        }
        else {
            ELog.Msg(mtInformation, "RenameItem: No thumbnail found for %s in $objects$", oldThmPath.c_str());
        }

        ELog.Msg(mtInformation, "RenameItem: Attempting to rename file %s to %s", oldFullPath.c_str(), newFullPath.c_str());
        if (MoveFileA(oldFullPath.c_str(), newFullPath.c_str())) {
            m_SelectedItem = resolvedNewPath;
            auto it = m_PreviewCache.find(resolvedOldPath);
            if (it != m_PreviewCache.end()) {
                m_PreviewCache.erase(it);
                auto cacheIt = std::find(m_CacheOrder.begin(), m_CacheOrder.end(), resolvedOldPath);
                if (cacheIt != m_CacheOrder.end()) {
                    m_CacheOrder.erase(cacheIt);
                }
            }
            if (thmRenamed) {
                LoadThumbnail(resolvedNewPath);
            }
            RefreshList();
            ELog.Msg(mtInformation, "File renamed successfully: %s to %s", normalizedOldPath.c_str(), normalizedNewPath.c_str());
        }
        else {
            DWORD error = GetLastError();
            ELog.DlgMsg(mtError, "Failed to rename file: %s to %s (Error code: %lu)", oldFullPath.c_str(), newFullPath.c_str(), error);
            if (thmRenamed) {
                ELog.Msg(mtInformation, "RenameItem: Attempting to revert thumbnail rename %s to %s", newThmFullPath.c_str(), oldThmFullPath.c_str());
                if (MoveFileA(newThmFullPath.c_str(), oldThmFullPath.c_str())) {
                    ELog.Msg(mtInformation, "Thumbnail rename reverted: %s back to %s", newThmPath.c_str(), oldThmPath.c_str());
                }
                else {
                    DWORD revertError = GetLastError();
                    ELog.DlgMsg(mtError, "Failed to revert thumbnail rename: %s to %s (Error code: %lu)", newThmFullPath.c_str(), oldThmFullPath.c_str(), revertError);
                }
            }
        }
    }
}

void UIContentBrowser::DeleteItem()
{
    if (m_SelectedItem.empty()) {
        ELog.DlgMsg(mtError, "No item selected for deletion.");
        return;
    }

    xr_string itemPath = m_CurrentPath;
    if (!itemPath.empty()) itemPath += "\\";
    itemPath += m_SelectedItem;

    xr_string normalizedPath = NormalizeName(itemPath);
    ELog.Msg(mtInformation, "DeleteItem: Attempting to delete %s", normalizedPath.c_str());

    xr_string trashPath = FS.get_path("$objects$")->m_Path + xr_string("_trash");
    CreateDirectoryA(trashPath.c_str(), NULL);
    ELog.Msg(mtInformation, "DeleteItem: Ensured _trash directory exists at %s", trashPath.c_str());

    string_path oldPhysicalPath;
    bool isFolder = false;

    if (FS.exist(oldPhysicalPath, "$fs_root$", (normalizedPath + "\\").c_str())) {
        isFolder = true;
        ELog.Msg(mtInformation, "DeleteItem: Item %s is a folder in $fs_root$", normalizedPath.c_str());
    }
    else {
        xr_string resolvedPath;
        if (ResolveObjectFile(normalizedPath, resolvedPath)) {
            isFolder = false;
            normalizedPath = resolvedPath;
            ELog.Msg(mtInformation, "DeleteItem: Resolved file path %s in $objects$", normalizedPath.c_str());
        }
        else {
            ELog.DlgMsg(mtError, "Item does not exist: %s (checked in $fs_root$ and $objects$)", normalizedPath.c_str());
            return;
        }
    }

    xr_string oldFullPath = (isFolder ? FS.get_path("$fs_root$") : FS.get_path("$objects$"))->m_Path + normalizedPath;
    xr_string trashDestPath = "_trash\\" + m_SelectedItem;
    if (isFolder) {
        trashDestPath += "\\";
    }
    else {
        size_t dotPos = normalizedPath.find_last_of('.');
        if (dotPos != xr_string::npos) {
            trashDestPath += normalizedPath.substr(dotPos);
        }
    }
    xr_string newFullPath = FS.get_path("$objects$")->m_Path + trashDestPath;

    if (FS.exist(oldPhysicalPath, isFolder ? "$fs_root$" : "$objects$", trashDestPath.c_str())) {
        ELog.DlgMsg(mtError, "Item already exists in trash: %s", trashDestPath.c_str());
        return;
    }

    ELog.Msg(mtInformation, "DeleteItem: Moving %s to %s", oldFullPath.c_str(), newFullPath.c_str());
    if (MoveFileA(oldFullPath.c_str(), newFullPath.c_str())) {
        ELog.Msg(mtInformation, "DeleteItem: Successfully moved %s to %s", normalizedPath.c_str(), trashDestPath.c_str());

        if (!isFolder) {
            xr_string oldFileName = normalizedPath;
            if (!m_CurrentPath.empty()) {
                size_t pos = normalizedPath.find(m_CurrentPath + "\\");
                if (pos == 0) {
                    oldFileName = normalizedPath.substr(m_CurrentPath.length() + 1);
                }
            }
            xr_string oldBaseName = m_CurrentPath;
            if (!oldBaseName.empty()) oldBaseName += "\\";
            oldBaseName += oldFileName.substr(0, oldFileName.find_last_of('.'));
            xr_string oldThmPath = oldBaseName + ".thm";
            xr_string newThmPath = "_trash\\" + m_SelectedItem.substr(0, m_SelectedItem.find_last_of('.')) + ".thm";
            xr_string oldThmFullPath = FS.get_path("$objects$")->m_Path + NormalizeName(oldThmPath);
            xr_string newThmFullPath = FS.get_path("$objects$")->m_Path + NormalizeName(newThmPath);

            ELog.Msg(mtInformation, "DeleteItem: Checking for thumbnail %s in $objects$", oldThmPath.c_str());
            if (FS.exist(oldPhysicalPath, "$objects$", oldThmPath.c_str())) {
                ELog.Msg(mtInformation, "DeleteItem: Found thumbnail %s in $objects$", oldThmPath.c_str());
                if (FS.exist(oldPhysicalPath, "$objects$", newThmPath.c_str())) {
                    ELog.DlgMsg(mtError, "Thumbnail already exists in trash: %s", newThmPath.c_str());
                }
                else {
                    ELog.Msg(mtInformation, "DeleteItem: Moving thumbnail %s to %s", oldThmFullPath.c_str(), newThmFullPath.c_str());
                    if (MoveFileA(oldThmFullPath.c_str(), newThmFullPath.c_str())) {
                        ELog.Msg(mtInformation, "DeleteItem: Thumbnail moved successfully: %s to %s", oldThmPath.c_str(), newThmPath.c_str());
                    }
                    else {
                        DWORD error = GetLastError();
                        ELog.DlgMsg(mtError, "DeleteItem: Failed to move thumbnail: %s to %s (Error code: %lu)", oldThmFullPath.c_str(), newThmFullPath.c_str(), error);
                    }
                }
            }
            else {
                ELog.Msg(mtInformation, "DeleteItem: No thumbnail found for %s in $objects$", oldThmPath.c_str());
            }

            auto it = m_PreviewCache.end();
            it = m_PreviewCache.find(normalizedPath);
            if (it != m_PreviewCache.end()) {
                m_PreviewCache.erase(it);
                auto cacheIt = m_CacheOrder.end();
                cacheIt = std::find(m_CacheOrder.begin(), m_CacheOrder.end(), normalizedPath);
                if (cacheIt != m_CacheOrder.end()) {
                    m_CacheOrder.erase(cacheIt);
                }
            }
        }

        m_SelectedItem.clear();
        m_PendingObject.clear();
        RefreshList();
    }
    else {
        DWORD error = GetLastError();
        ELog.DlgMsg(mtError, "DeleteItem: Failed to move %s to %s (Error code: %lu)", oldFullPath.c_str(), newFullPath.c_str(), error);
    }
}

void UIContentBrowser::RefreshList()
{
    if (m_RefreshInProgress)
        return;
    m_RefreshInProgress = true;
    m_Items.clear();
    ListItemsVec items;
    FS_FileSet lst;
    if (Lib.GetObjects(lst))
    {
        xr_string searchLower = m_SearchQuery;
        std::transform(searchLower.begin(), searchLower.end(), searchLower.begin(), [](char c) { return std::tolower(c); });

        for (const auto& file : lst)
        {
            xr_string relativeName = file.name;
            if (!m_CurrentPath.empty())
            {
                if (relativeName.find(m_CurrentPath + "\\") != 0)
                    continue;
                relativeName = relativeName.substr(m_CurrentPath.length() + 1);
            }
            xr_string relativeLower = relativeName;
            std::transform(relativeLower.begin(), relativeLower.end(), relativeLower.begin(), [](char c) { return std::tolower(c); });
            if (!m_SearchQuery.empty() && relativeLower.find(searchLower) == xr_string::npos)
                continue;
            size_t pos = relativeName.find('\\');
            Item item;
            item.isFolder = pos != xr_string::npos;
            item.name = item.isFolder ? relativeName.substr(0, pos) : relativeName;
            if (!IsValidName(item.name))
                continue;
            auto it = std::find_if(m_Items.begin(), m_Items.end(),
                [&item](const Item& i) { return i.name == item.name && i.isFolder == item.isFolder; });
            if (it == m_Items.end())
                m_Items.push_back(item);
            if (!item.isFolder)
                LoadThumbnail(item.name);
        }
    }
    std::sort(m_Items.begin(), m_Items.end(),
        [](const Item& a, const Item& b) { return a.isFolder == b.isFolder ? a.name < b.name : a.isFolder > b.isFolder; });
    for (auto& item : m_Items)
        if (!item.isFolder)
            LoadThumbnail(item.name);
    m_ObjectList->AssignItems(items);
    BuildDirectoryTree();
    m_RefreshInProgress = false;
}

void UIContentBrowser::OnItemClicked(const xr_string& item, bool isFolder, const xr_string& itemPath)
{
    if (isFolder && !item.empty())
    {
        xr_string newPath = itemPath;
        FS_FileSet lst;
        if (Lib.GetObjects(lst))
        {
            bool pathExists = false;
            for (const auto& file : lst)
                if (file.name.find(newPath + "\\") == 0 || file.name == newPath)
                {
                    pathExists = true;
                    break;
                }
            if (pathExists)
            {
                m_PathHistory.push_back(m_CurrentPath);
                m_PreviewCache.clear();
                m_CacheOrder.clear();
                m_CurrentPath = newPath;
                m_SelectedItem.clear();
                m_PendingObject.clear();
                RefreshList();
            }
        }
    }
    else if (!isFolder && IsValidName(item))
    {
        m_SelectedItem = item;
        ESceneObjectTool* objTool = dynamic_cast<ESceneObjectTool*>(Scene->GetTool(OBJCLASS_SCENEOBJECT));
        if (objTool && objTool->pForm)
            if (UIObjectTool* uiObjTool = dynamic_cast<UIObjectTool*>(objTool->pForm)) {
                xr_string fullPath = m_CurrentPath;
                if (!fullPath.empty()) fullPath += "\\";
                fullPath += m_SelectedItem;
                uiObjTool->SetCurrent(fullPath.c_str());
                m_PendingObject = fullPath;
            }
    }
}

ImTextureID UIContentBrowser::LoadThumbnail(const xr_string& name)
{
    xr_string fullPath = m_CurrentPath;
    if (!fullPath.empty()) fullPath += "\\";
    fullPath += name;
    fullPath = NormalizeName(fullPath);

    xr_string thmPath = fullPath;
    size_t dotPos = thmPath.find_last_of('.');
    if (dotPos != xr_string::npos)
        thmPath = thmPath.substr(0, dotPos);
    thmPath += ".thm";

    auto it = m_PreviewCache.find(fullPath);
    if (it != m_PreviewCache.end())
        return it->second;

    string_path tmp;
    if (FS.exist(tmp, "$objects$", thmPath.c_str()))
    {
        CTexture* t = xr_new<CTexture>();
        t->Load(thmPath.c_str());
        m_PreviewCache[fullPath] = t->surface_get();
        m_CacheOrder.push_back(fullPath);
        return t->surface_get();
    }
    return m_TextureNull->surface_get();
}






void UIContentBrowser::AddObjectToScene(const xr_string& itemName, const Fvector& pos)
{
    if (itemName.empty()) {
        ELog.Msg(mtInformation, "AddObjectToScene: Empty itemName");
        return;
    }

    xr_string relativePath;
    if (!ResolveObjectFile(itemName, relativePath)) {
        relativePath = NormalizeName(itemName);
        ELog.Msg(mtInformation, "AddObjectToScene: Invalid path: %s", relativePath.c_str());
        return;
    }

    string_path physicalPath;
    if (!FS.exist(physicalPath, "$objects$", relativePath.c_str())) {
        ELog.Msg(mtInformation, "AddObjectToScene: File not found: %s", relativePath.c_str());
        ELog.DlgMsg(mtError, "Object file does not exist: %s", relativePath.c_str());
        return;
    }

    xr_string objectName = relativePath;
    size_t dotPos = objectName.find_last_of('.');
    if (dotPos != xr_string::npos)
        objectName = objectName.substr(0, dotPos);

    string256 namebuffer;
    Scene->GenObjectName(OBJCLASS_SCENEOBJECT, namebuffer, objectName.c_str());

    CSceneObject* obj = xr_new<CSceneObject>((LPVOID)0, namebuffer);
    CEditableObject* ref = obj->SetReference(relativePath.c_str());
    if (!ref) {
        ELog.Msg(mtInformation, "AddObjectToScene: Failed to load: %s", relativePath.c_str());
        xr_delete(obj);
        ELog.DlgMsg(mtError, "Failed to load object: %s", relativePath.c_str());
        return;
    }

    Fvector up = { 0.f, 1.f, 0.f };
    obj->MoveTo(pos, up);
    Scene->AppendObject(obj);
    Scene->SelectObjects(false, OBJCLASS_SCENEOBJECT);
    obj->Select(true);

    ELog.Msg(mtInformation, "AddObjectToScene: Added: %s", namebuffer);

    ESceneObjectTool* objTool = dynamic_cast<ESceneObjectTool*>(Scene->GetTool(OBJCLASS_SCENEOBJECT));
    if (objTool && objTool->pForm) {
        UIObjectTool* uiObjTool = dynamic_cast<UIObjectTool*>(objTool->pForm);
        if (uiObjTool)
            uiObjTool->SetCurrent(relativePath.c_str());
    }
}

bool UIContentBrowser::GetMouseScenePosition(Fvector& pos)
{
    Ivector2 mousePos = UI->GetRenderMousePosition();
    Fvector start, dir;
    EDevice->m_Camera.MouseRayFromPoint(start, dir, mousePos);
    float dist = 1000.f;
    Fvector hit;
    if (Scene->RayPick(start, dir, dist, &hit, nullptr)) {
        pos = hit;
        return true;
    }
    return false;
}